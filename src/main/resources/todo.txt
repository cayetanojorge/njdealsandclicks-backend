TODO

- fare struttura per blog: tabelle e come relazionare blog a prodotti menzionati nell'articolo

- DOMANI (quando avrai utenti registrati o funzionalit√† sensibili):
  ‚úÖ Implementa JWT Authentication
    - Backend: Spring Boot (spring-security + jjwt / jose4j / nimbus-jose-jwt)
    - Configura rotte sicure per /api/user/** e simili
    - Usa filter per validare il token in ogni richiesta
    - Crea endpoint: /auth/register, /auth/login (restituisce JWT), /auth/refresh (se serve)
  
  ‚úÖ Frontend:
    - Salva il token JWT in localStorage (o in cookie httpOnly se serve maggiore sicurezza)
    - Aggiungi il token nell‚ÄôAuthorization header (Bearer <token>) in ogni richiesta autenticata
    - Gestisci scadenza token e logout automatico


- Inserire rate limiting su Fly.io (evitare mutli richieste da stesso ip e scraping, evita aumento costo fly io):
  ‚úÖ Configura nginx come reverse proxy con limit_req per IP
    - Modifica/aggiungi: Dockerfile, nginx.conf, fly.toml
    - Servizio: `njdealsandclicks-proxy`
    - Definisci burst e limite/s (es. 10 richieste/s con burst 20 per IP)


- QUANDO IL BACKEND SAR√Ä PRONTO AL DEPLOY STABILE:
  ‚úÖ Opzione A - Google Cloud Run (consigliata se vuoi scalabilit√† automatica, niente manutenzione):
    - Scrivi Dockerfile ottimizzato per Spring Boot (con JAR fat o native image GraalVM se vuoi avvio istantaneo)
    - Registra account Google Cloud e crea un progetto
    - Abilita Cloud Run API
    - Installa e configura `gcloud CLI`
    - Builda e pusha immagine backend su Google Container Registry (GCR) o Artifact Registry
    - Esegui `gcloud run deploy` scegliendo regione `europe-west3` (Francoforte)
    - Configura:
        - accesso pubblico (no autenticazione richiesta)
        - 512MB RAM, 1 vCPU
        - max instances: 1‚Äì2 (per evitare esplosione costi)
    - (Opzionale) Aggiungi cron job su Vercel o servizio esterno per pingare e prevenire cold start
  ‚úÖ Opzione B - Oracle Cloud Free Tier (consigliata se vuoi controllo totale a costo zero):
    - Registra account Oracle Cloud con dati reali e verifica identit√†
    - Crea una Compute Instance ARM gratuita (`VM.Standard.A1.Flex`)
    - Configura: 1 OCPU + 2 o 4 GB RAM
    - Abilita porte pubbliche (es. 8080) in regole di sicurezza
    - Connettiti via SSH
    - Installa Docker e Java nella VM
    - Esegui Spring Boot come container o JAR standalone
    - Aggiungi systemd service o script avvio automatico
    - (Opzionale) Proteggi VM con fail2ban o firewall base (UFW)
  ‚ùóÔ∏èIn entrambi i casi:
    - Assicurati che il backend NON dipenda da filesystem locale o DB locale (usa solo Supabase o esterni)
    - Verifica che tutte le rotte rispondano correttamente da Vercel ‚Üí backend
    - Aggiorna frontend per usare il nuovo dominio backend (Cloud Run URL o IP Oracle)

- üîÑ TODO FUTURO: Sostituire @ManyToMany con entit√† ponte (es. NewsletterProduct, ArticleProduct)
  Attualmente stai usando @ManyToMany per mappare newsletter ‚Üí prodotti e articoli ‚Üí prodotti.
  Quando il progetto evolver√†, valuta di passare a entit√† intermedie dedicate per ottenere:
  maggiore flessibilit√† (es. aggiungere campi come subscribed_at, priority, note, mercato ecc.)
  controllo totale su creazione/modifica/eliminazione
  performance migliorata con indici mirati
  üìå Priorit√†: media
  üìÖ Tempistica: quando inizierai ad avere iscrizioni utenti reali o blog attivi in pi√π mercati

- ‚úÖ Inizializzare gestione schema DB con Flyway (migrazioni versionate)
  Attualmente stai usando spring.jpa.hibernate.ddl-auto=update, ma per un'app solida e scalabile √® meglio mantenere lo schema con migrazioni esplicite.
  ‚úÖ Passi:
  Aggiungi dipendenza Flyway (flyway-core) nel backend
  Disattiva ddl-auto (validate o none) in application.yml
  Crea cartella src/main/resources/db/migration
  Crea file V1__init_schema.sql con lo stato attuale delle tabelle
  Usa Flyway per ogni modifica futura (es. V2__add_slug_to_article.sql)
  üìå Benefici:
  Gestione tracciabile e sicura dello schema DB
  Allineamento automatico tra ambienti dev/test/prod
  Compatibile con Supabase (PostgreSQL)
  üìÖ Tempistica: Subito, prima che il progetto cresca troppo e sia difficile esportare lo schema corrente
  --> USO:
  cos√¨ posso creare in tabella intermedia newsletter_product e newsletter_category il ON DELETE CASCADE a id newsletter e id product.
  cos√¨ in caso eliminato:
    . record newsletter, allora eliminato tutte record in entrambi tab newsletter_... che gli fanno riferimento
    . record product, eliminato riferimento a tale prodotto in tabella newsletter_product
    . record category, eliminato riferimento a tale prodotto in tabella newsletter_category
  cos√¨ anche per article_product, quando elimino prodotto, se c'√® record in tale tabella allora eliminata
  (per√≤ come fare per tracciare/avvisare a utente che tale prodotto/categoria che voleva seguire non esiste pi√π?
   o come fare a controllare che se articolo che faceva riferimento a tale prodotto eliminato me ne accorga cos√¨ da eliminare o modificare articolo?
   forse meglio non mettere on delete cascade?)
  soluzione:
  -> Implementare gestione sicura della cancellazione di Product/Category:
      ‚û§ Evitare ON DELETE CASCADE automatico nei join @ManyToMany
      ‚û§ Prima di cancellare, verificare se il record √® referenziato da Newsletter o Article
        boolean isUsedInNewsletter = newsletterRepository.existsByProductsContains(product);
        boolean isUsedInArticle = articleRepository.existsByProductsContains(product);
      ‚û§ In caso positivo:
           - Notificare utente/admin
           - Rimuovere manualmente i riferimenti o disattivare (es. isAvailable = false)
      ‚û§ (Futuro) Passare a entit√† ponte con campo deletedAt per gestione soft delete

- ‚úÖ Implementare Soft Delete (coem fatto in entity User e Article isDeleted isActive deleted_at deactivated_at)
  e gestione sicura delle relazioni critiche (Product, Category, Article)
  ‚ùó Evita cancellazioni fisiche di entit√† referenziate (Product, Category) per non rompere integrit√† delle relazioni (Newsletter, Article, ecc.)
  ‚úÖ Passaggi:
  Aggiungi campo is_deleted (boolean, default false) o deleted_at (timestamp) alle entit√† Product, Category, Article, ecc.
  Modifica la logica di eliminazione in service:
  Invece di repository.delete(...), esegui setIsDeleted(true) o setDeletedAt(...)
  Filtra nei repository solo gli elementi attivi (is_deleted = false)
  Non utilizzare ON DELETE CASCADE nelle tabelle intermedie (newsletter_product, article_product, ecc.)
  üí° Controlli preventivi prima di eliminare Product o Category:
    boolean usedInNewsletter = newsletterRepository.existsByProductsContains(product);
    boolean usedInArticle = articleRepository.existsByProductsContains(product);
  ‚û° In caso positivo:
  Mostrare avviso/admin o log
  Rimuovere manualmente i riferimenti oppure disattivare (isAvailable = false)
  üìå Benefici:
  Maggiore controllo sulle dipendenze
  Nessuna perdita accidentale di dati
  Tracciabilit√† e rollback pi√π semplice
  üìÖ Tempistica: prima di andare live o alla prima gestione massiva di prodotti/categorie

- üìö Implementare suggerimento "Articoli Simili" nel frontend
  ‚û§ Obiettivo: mentre un utente legge un articolo, mostrare un elenco di articoli simili per aumentare engagement e tempo sul sito.
  ‚úÖ Logica Backend:
    Restituire articoli simili tramite endpoint dedicato:
      GET /api/articles/{publicId}/related
    Criteri consigliati:
      .Match su tags (con tags && :currentTags in PostgreSQL)
      .Match su categorie dei prodotti associati all‚Äôarticolo corrente
      .(Futuro) Match combinato o ranking per rilevanza
  ‚úÖ Frontend:
    Integra sezione "Articoli Consigliati" sotto o accanto all‚Äôarticolo
    Mostra titolo, immagine, breve excerpt e link
  üìå Priorit√†: media
  üìÖ Tempistica: quando hai almeno 5‚Äì10 articoli pubblicati per categoria o tag