TODO

- fare struttura per blog: tabelle e come relazionare blog a prodotti menzionati nell'articolo

- DOMANI (quando avrai utenti registrati o funzionalitÃ  sensibili):
  âœ… Implementa JWT Authentication
    - Backend: Spring Boot (spring-security + jjwt / jose4j / nimbus-jose-jwt)
    - Configura rotte sicure per /api/user/** e simili
    - Usa filter per validare il token in ogni richiesta
    - Crea endpoint: /auth/register, /auth/login (restituisce JWT), /auth/refresh (se serve)
  
  âœ… Frontend:
    - Salva il token JWT in localStorage (o in cookie httpOnly se serve maggiore sicurezza)
    - Aggiungi il token nellâ€™Authorization header (Bearer <token>) in ogni richiesta autenticata
    - Gestisci scadenza token e logout automatico


- Inserire rate limiting su Fly.io (evitare mutli richieste da stesso ip e scraping, evita aumento costo fly io):
  âœ… Configura nginx come reverse proxy con limit_req per IP
    - Modifica/aggiungi: Dockerfile, nginx.conf, fly.toml
    - Servizio: `njdealsandclicks-proxy`
    - Definisci burst e limite/s (es. 10 richieste/s con burst 20 per IP)


- QUANDO IL BACKEND SARÃ€ PRONTO AL DEPLOY STABILE:
  âœ… Opzione A - Google Cloud Run (consigliata se vuoi scalabilitÃ  automatica, niente manutenzione):
    - Scrivi Dockerfile ottimizzato per Spring Boot (con JAR fat o native image GraalVM se vuoi avvio istantaneo)
    - Registra account Google Cloud e crea un progetto
    - Abilita Cloud Run API
    - Installa e configura `gcloud CLI`
    - Builda e pusha immagine backend su Google Container Registry (GCR) o Artifact Registry
    - Esegui `gcloud run deploy` scegliendo regione `europe-west3` (Francoforte)
    - Configura:
        - accesso pubblico (no autenticazione richiesta)
        - 512MB RAM, 1 vCPU
        - max instances: 1â€“2 (per evitare esplosione costi)
    - (Opzionale) Aggiungi cron job su Vercel o servizio esterno per pingare e prevenire cold start
  âœ… Opzione B - Oracle Cloud Free Tier (consigliata se vuoi controllo totale a costo zero):
    - Registra account Oracle Cloud con dati reali e verifica identitÃ 
    - Crea una Compute Instance ARM gratuita (`VM.Standard.A1.Flex`)
    - Configura: 1 OCPU + 2 o 4 GB RAM
    - Abilita porte pubbliche (es. 8080) in regole di sicurezza
    - Connettiti via SSH
    - Installa Docker e Java nella VM
    - Esegui Spring Boot come container o JAR standalone
    - Aggiungi systemd service o script avvio automatico
    - (Opzionale) Proteggi VM con fail2ban o firewall base (UFW)
  â—ï¸In entrambi i casi:
    - Assicurati che il backend NON dipenda da filesystem locale o DB locale (usa solo Supabase o esterni)
    - Verifica che tutte le rotte rispondano correttamente da Vercel â†’ backend
    - Aggiorna frontend per usare il nuovo dominio backend (Cloud Run URL o IP Oracle)

- ğŸ”„ TODO FUTURO: Sostituire @ManyToMany con entitÃ  ponte (es. NewsletterProduct, ArticleProduct)
  Attualmente stai usando @ManyToMany per mappare newsletter â†’ prodotti e articoli â†’ prodotti.
  Quando il progetto evolverÃ , valuta di passare a entitÃ  intermedie dedicate per ottenere:
  maggiore flessibilitÃ  (es. aggiungere campi come subscribed_at, priority, note, mercato ecc.)
  controllo totale su creazione/modifica/eliminazione
  performance migliorata con indici mirati
  ğŸ“Œ PrioritÃ : media
  ğŸ“… Tempistica: quando inizierai ad avere iscrizioni utenti reali o blog attivi in piÃ¹ mercati

- âœ… Inizializzare gestione schema DB con Flyway (migrazioni versionate)
  Attualmente stai usando spring.jpa.hibernate.ddl-auto=update, ma per un'app solida e scalabile Ã¨ meglio mantenere lo schema con migrazioni esplicite.
  âœ… Passi:
  Aggiungi dipendenza Flyway (flyway-core) nel backend
  Disattiva ddl-auto (validate o none) in application.yml
  Crea cartella src/main/resources/db/migration
  Crea file V1__init_schema.sql con lo stato attuale delle tabelle
  Usa Flyway per ogni modifica futura (es. V2__add_slug_to_article.sql)
  ğŸ“Œ Benefici:
  Gestione tracciabile e sicura dello schema DB
  Allineamento automatico tra ambienti dev/test/prod
  Compatibile con Supabase (PostgreSQL)
  ğŸ“… Tempistica: Subito, prima che il progetto cresca troppo e sia difficile esportare lo schema corrente
  --> USO:
  cosÃ¬ posso creare in tabella intermedia newsletter_product e newsletter_category il ON DELETE CASCADE a id newsletter e id product.
  cosÃ¬ in caso eliminato:
    . record newsletter, allora eliminato tutte record in entrambi tab newsletter_... che gli fanno riferimento
    . record product, eliminato riferimento a tale prodotto in tabella newsletter_product
    . record category, eliminato riferimento a tale prodotto in tabella newsletter_category
  cosÃ¬ anche per article_product, quando elimino prodotto, se c'Ã¨ record in tale tabella allora eliminata
  (perÃ² come fare per tracciare/avvisare a utente che tale prodotto/categoria che voleva seguire non esiste piÃ¹?
   o come fare a controllare che se articolo che faceva riferimento a tale prodotto eliminato me ne accorga cosÃ¬ da eliminare o modificare articolo?
   forse meglio non mettere on delete cascade?)
  soluzione:
  -> Implementare gestione sicura della cancellazione di Product/Category:
      â¤ Evitare ON DELETE CASCADE automatico nei join @ManyToMany
      â¤ Prima di cancellare, verificare se il record Ã¨ referenziato da Newsletter o Article
        boolean isUsedInNewsletter = newsletterRepository.existsByProductsContains(product);
        boolean isUsedInArticle = articleRepository.existsByProductsContains(product);
      â¤ In caso positivo:
           - Notificare utente/admin
           - Rimuovere manualmente i riferimenti o disattivare (es. isAvailable = false)
      â¤ (Futuro) Passare a entitÃ  ponte con campo deletedAt per gestione soft delete

- âœ… Implementare Soft Delete (coem fatto in entity User e Article isDeleted isActive deleted_at deactivated_at)
  e gestione sicura delle relazioni critiche (Product, Category, Article)
  â— Evita cancellazioni fisiche di entitÃ  referenziate (Product, Category) per non rompere integritÃ  delle relazioni (Newsletter, Article, ecc.)
  âœ… Passaggi:
  Aggiungi campo is_deleted (boolean, default false) o deleted_at (timestamp) alle entitÃ  Product, Category, Article, ecc.
  Modifica la logica di eliminazione in service:
  Invece di repository.delete(...), esegui setIsDeleted(true) o setDeletedAt(...)
  Filtra nei repository solo gli elementi attivi (is_deleted = false)
  Non utilizzare ON DELETE CASCADE nelle tabelle intermedie (newsletter_product, article_product, ecc.)
  ğŸ’¡ Controlli preventivi prima di eliminare Product o Category:
    boolean usedInNewsletter = newsletterRepository.existsByProductsContains(product);
    boolean usedInArticle = articleRepository.existsByProductsContains(product);
  â¡ In caso positivo:
  Mostrare avviso/admin o log
  Rimuovere manualmente i riferimenti oppure disattivare (isAvailable = false)
  ğŸ“Œ Benefici:
  Maggiore controllo sulle dipendenze
  Nessuna perdita accidentale di dati
  TracciabilitÃ  e rollback piÃ¹ semplice
  ğŸ“… Tempistica: prima di andare live o alla prima gestione massiva di prodotti/categorie

- ğŸ“š Implementare suggerimento "Articoli Simili" nel frontend
  â¤ Obiettivo: mentre un utente legge un articolo, mostrare un elenco di articoli simili per aumentare engagement e tempo sul sito.
  âœ… Logica Backend:
    Restituire articoli simili tramite endpoint dedicato:
      GET /api/articles/{publicId}/related
    Criteri consigliati:
      .Match su tags (con tags && :currentTags in PostgreSQL)
      .Match su categorie dei prodotti associati allâ€™articolo corrente
      .(Futuro) Match combinato o ranking per rilevanza
  âœ… Frontend:
    Integra sezione "Articoli Consigliati" sotto o accanto allâ€™articolo
    Mostra titolo, immagine, breve excerpt e link
  ğŸ“Œ PrioritÃ : media
  ğŸ“… Tempistica: quando hai almeno 5â€“10 articoli pubblicati per categoria o tag



â€“ Gestione Newsletter e Email Audience (fase futura)
- âœ… Creare tabella email_audience (base per utenti iscritti alla newsletter):
. Campi:
id, email (unique), is_active, email_verified,
default_country_code, locale, timezone,
consent_at, consent_source, deactivated_at, user_id (nullable FK)
. user_id collegato in futuro a User (quando introdurrai il login)
. Indice su email e user_id
. Gestione deactivated_at per disiscrizione utenti

- â• Consentire iscrizione da diversi punti del sito:
Home page:
â†’ utente vuole ricevere aggiornamenti generali (newsletter globale)
â†’ salva in email_audience + default_country_code del mercato corrente
â†’ se si iscrive da un mercato diverso, aggiungere record in tabella secondaria email_audience_market_pref
Pagina prodotto:
â†’ utente interessato a quello specifico prodotto
â†’ salva in email_audience + crea record in tabella email_audience_product_pref
â†’ riferimento deve essere a product_market_id (non solo al link affiliato)
Pagina articoli/blog generale:
â†’ utente vuole aggiornamenti sugli articoli pubblicati
â†’ salva in email_audience + email_audience_article_pref con tipo â€œgeneral_articlesâ€
Pagina di un singolo articolo:
â†’ utente riceverÃ  aggiornamenti sui prodotti menzionati in quellâ€™articolo
â†’ salva in email_audience + email_audience_product_pref per ogni ProductMarket menzionato
â†’ opzionale: salva anche preferenza per categoria/tag dellâ€™articolo in email_audience_article_pref

- â• Tabella secondarie di preferenze:
. email_audience_market_pref â†’ per utenti interessati a piÃ¹ mercati (country_code, audience_id)
. email_audience_product_pref â†’ per prodotti specifici (product_market_id, audience_id)
. email_audience_article_pref â†’ per tag o categorie articoli (category_id o tag + audience_id)

- âš™ï¸ Service EmailAudienceService
. subscribeGeneral(email, countryCode, source) â†’ newsletter generale
. subscribeProduct(email, productPublicId, countryCode, source) â†’ prodotto specifico
. subscribeArticles(email, countryCode, tagsOrCategoryIds, source) â†’ articoli per categoria
. subscribeFromArticle(email, articleSlug, countryCode) â†’ prodotti menzionati nellâ€™articolo
. unsubscribe(email) â†’ set is_active = false + deactivated_at = now()
. (futuro) linkToUserOnSignup(User user) â†’ collega account registrato allâ€™audience

- âš™ï¸ Controller pubblici:
POST /api/public/newsletter/subscribe
POST /api/public/newsletter/subscribe-product
POST /api/public/newsletter/subscribe-articles
POST /api/public/newsletter/subscribe-from-article
POST /api/public/newsletter/unsubscribe

- ğŸ”„ Logica dâ€™iscrizione idempotente
. Se email giÃ  presente â†’ aggiorna consent_source e aggiungi solo nuove preferenze
. Non sovrascrivere consent_at o default_country_code esistenti
. Multi-mercato supportato: aggiungere record in market_pref, non sostituire

- ğŸ•’ Gestione disiscrizione:
. Non cancellare fisicamente il record
. Imposta is_active=false, deactivated_at=ZonedDateTime.now()
. Facile riattivazione in caso di nuova iscrizione (reset is_active=true)

- ğŸ“… Cron Job / Integrazione futura
(Fase 2) job settimanale che invia â€œWeekly Digestâ€ con nuovi articoli e offerte del mercato selezionato
(Fase 3) job per â€œProduct Alertsâ€ in caso di calo di prezzo su product_market_id seguiti

- ğŸ“œ Compliance e sicurezza
. Double opt-in (facoltativo ora, ma previsto)
. Audit: consent_at, consent_source, deactivated_at
. One-click unsubscribe (token firmato)
. Rate limit iscrizioni per IP/email

ğŸ“Š Analytics (futuro)
Numero iscritti per mercato
Iscritti attivi per tipo (generale, prodotto, articolo)
Origine iscrizione (consent_source â†’ â€œhomeâ€, â€œproduct_pageâ€, â€œarticle_pageâ€, ecc.)

ğŸ“Œ PrioritÃ : bassa (futura evoluzione)
ğŸ“… Tempistica consigliata: dopo il deploy stabile del blog e dei prodotti multi-market
ğŸ¯ Obiettivo: costruire base per email marketing segmentato per mercato, prodotto o categoria